; Listing generated by Microsoft (R) Optimizing Compiler Version 19.30.30706.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__5B95AFCC_concurrencysal@h DB 01H
__AF7C3541_sal@h DB 01H
__FF4CBCD4_vadefs@h DB 01H
__EF9B48C8_vcruntime@h DB 01H
__0B460DD5_xkeycheck@h DB 01H
__518BDD87_yvals_core@h DB 01H
__3937FC8D_limits@h DB 01H
__A64D14EB_climits DB 01H
__6569C2CA_corecrt@h DB 01H
__356604CF_vcruntime_new@h DB 01H
__6C55A9F6_vcruntime_new_debug@h DB 01H
__49916C16_crtdbg@h DB 01H
__98E9459B_crtdefs@h DB 01H
__7B851503_use_ansi@h DB 01H
__94E280A6_yvals@h DB 01H
__741AE07E_corecrt_math@h DB 01H
__91D68F2D_math@h DB 01H
__6C20D4D3_corecrt_malloc@h DB 01H
__C9393812_stddef@h DB 01H
__D493B9BD_corecrt_search@h DB 01H
__1473E23E_corecrt_wstdlib@h DB 01H
__B49664B7_stdlib@h DB 01H
__22A23619_cstdlib DB 01H
__808B274A_xtr1common DB 01H
__DB8DB16E_intrin0@inl@h DB 01H
__81C4FC90_intrin0@h DB 01H
__CDC63BF6_cmath DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__3434F1A4_cstdio DB 01H
__CDDAF8CA_errno@h DB 01H
__E6DA1474_vcruntime_string@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__A751F051_corecrt_memory@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__32E5F013_string@h DB 01H
__6E309EF9_cstring DB 01H
__C6E16F6F_corecrt_wconio@h DB 01H
__5DB64B66_corecrt_wctype@h DB 01H
__CB8D9B53_corecrt_wdirect@h DB 01H
__A9063C41_corecrt_share@h DB 01H
__6D390390_corecrt_wio@h DB 01H
__61BDDCD5_corecrt_wprocess@h DB 01H
__1157D6BA_corecrt_wtime@h DB 01H
__64F617E8_types@h DB 01H
__1DC1E279_stat@h DB 01H
__93DC0B45_wchar@h DB 01H
__AEBF27F7_cwchar DB 01H
__8769ECB4_cstddef DB 01H
__4153D9FF_initializer_list DB 01H
__E2B02480_xstddef DB 01H
__ED7FA2C1_iosfwd DB 01H
__8741D2B2_stdint@h DB 01H
__9FFCD764_cstdint DB 01H
__45EFCB1E_type_traits DB 01H
__15AFB392_utility DB 01H
__EB99AA4F_xutility DB 01H
__FA351D0F_iterator DB 01H
__5B81F060_share@h DB 01H
__69F41CE0___msvc_system_error_abi@hpp DB 01H
__A915855F_cerrno DB 01H
__20BB4341_malloc@h DB 01H
__3C5D8049_corecrt_terminate@h DB 01H
__517DF72F_eh@h DB 01H
__64BBACA4_vcruntime_exception@h DB 01H
__50B62B0D_exception DB 01H
__158E8E48_float@h DB 01H
__47703A23_cfloat DB 01H
__35511E07_isa_availability@h DB 01H
__21967747_limits DB 01H
__08BB6DA5_new DB 01H
__5ABAA7DB_xatomic@h DB 01H
__7F3AD051_xmemory DB 01H
__0BE956CD_xstring DB 01H
__D9F81150_stdexcept DB 01H
__121303D7_xcall_once@h DB 01H
__3C7795A9_xerrc@h DB 01H
__A0B61CF9_time@h DB 01H
__0B75A7FE_ctime DB 01H
__5D5D490E_xtimec@h DB 01H
__1ACB22B0_xthreads@h DB 01H
__4AA32B85_atomic DB 01H
__AD4E11F7_system_error DB 01H
__C40BCBAA_vcruntime_typeinfo@h DB 01H
__9B465956_typeinfo DB 01H
__9D387BC9_memory DB 01H
__B17D2CC6_xfacet DB 01H
__7C272235___msvc_xlocinfo_types@hpp DB 01H
__B2D2BA86_ctype@h DB 01H
__3BFF1603_cctype DB 01H
__A3D09DBA_locale@h DB 01H
__B10EEAC8_clocale DB 01H
__84CFBA9E_xlocinfo DB 01H
__D4D722FC_xlocale DB 01H
__BD2ACD8D_xiosbase DB 01H
__DB58A9EC_streambuf DB 01H
__4A5044EB_xlocnum DB 01H
__F07657B3_ios DB 01H
__C7C7F838_ostream DB 01H
__A417CD02_istream DB 01H
__89E0D050_iostream DB 01H
__7D9C9A72_Sorts@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?__empty_global_delete@@YAXPEAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAX_K@Z		; __empty_global_delete
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?ShakerSort@@YAXHQEAH@Z				; ShakerSort
PUBLIC	?SelectionSort@@YAXHQEAH@Z			; SelectionSort
PUBLIC	?InsertSort@@YAXHQEAH@Z				; InsertSort
PUBLIC	?ShellSort@@YAXHQEAH@Z				; ShellSort
PUBLIC	?BubleSort@@YAXHQEAH@Z				; BubleSort
PUBLIC	?code@@YAXPEBD@Z				; code
PUBLIC	main
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	__JustMyCode_Default
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	__imp_?good@ios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEBA_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEAA_J_J@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__empty_global_delete@@YAXPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?__empty_global_delete@@YAXPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__empty_global_delete@@YAXPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?__empty_global_delete@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z DD imagerel $LN5
	DD	imagerel $LN5+95
	DD	imagerel $unwind$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eof@?$_Narrow_char_traits@DH@std@@SAHXZ DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ShakerSort@@YAXHQEAH@Z DD imagerel $LN13
	DD	imagerel $LN13+464
	DD	imagerel $unwind$?ShakerSort@@YAXHQEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SelectionSort@@YAXHQEAH@Z DD imagerel $LN10
	DD	imagerel $LN10+221
	DD	imagerel $unwind$?SelectionSort@@YAXHQEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InsertSort@@YAXHQEAH@Z DD imagerel $LN10
	DD	imagerel $LN10+195
	DD	imagerel $unwind$?InsertSort@@YAXHQEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ShellSort@@YAXHQEAH@Z DD imagerel $LN13
	DD	imagerel $LN13+272
	DD	imagerel $unwind$?ShellSort@@YAXHQEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?BubleSort@@YAXHQEAH@Z DD imagerel $LN10
	DD	imagerel $LN10+237
	DD	imagerel $unwind$?BubleSort@@YAXHQEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?code@@YAXPEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+101
	DD	imagerel $unwind$?code@@YAXPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DD imagerel $LN23
	DD	imagerel $LN23+1003
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA DD imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA
	DD	imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA+36
	DD	imagerel $unwind$?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA DD imagerel ?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA
	DD	imagerel ?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA+80
	DD	imagerel $unwind$?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN4
	DD	imagerel $LN4+148
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+120
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN7
	DD	imagerel $LN7+261
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA DD imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA+39
	DD	imagerel $unwind$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+116
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 025051319H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 06H
	DB	00H
	DB	00H
	DB	'p'
	DB	02H
	DB	0f1H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 025051811H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 025051319H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03aH
	DW	03d2H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DB 0aH
	DB	00H
	DB	00H
	DB	0caH
	DB	02H
	DB	011H, 02H
	DB	04H
	DB	08dH, 09H
	DB	02H
	DB	0c0H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DB 02H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA
	DB	028H
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DB 038H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z DD 025054119H
	DD	01122317H
	DD	0700b0049H
	DD	0500aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
	DD	023bH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z$rtcName$0 DB 05fH ; std::operator<<<std::char_traits<char> >
	DB	04fH
	DB	06bH
	DB	00H
	ORG $+12
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z$rtcVarDesc DD 048H ; std::operator<<<std::char_traits<char> >
	DD	010H
	DQ	FLAT:??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z$rtcName$0
	ORG $+48
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z$rtcFrameData DD 01H ; std::operator<<<std::char_traits<char> >
	DD	00H
	DQ	FLAT:??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?code@@YAXPEBD@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?BubleSort@@YAXHQEAH@Z DD 025051701H
	DD	01122317H
	DD	0700b0029H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ShellSort@@YAXHQEAH@Z DD 025051701H
	DD	01122317H
	DD	0700b0031H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InsertSort@@YAXHQEAH@Z DD 025051701H
	DD	01122317H
	DD	0700b0029H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SelectionSort@@YAXHQEAH@Z DD 025051701H
	DD	01122317H
	DD	0700b002dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ShakerSort@@YAXHQEAH@Z DD 025051701H
	DD	01122317H
	DD	0700b0035H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eof@?$_Narrow_char_traits@DH@std@@SAHXZ DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__empty_global_delete@@YAXPEAX_K@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__empty_global_delete@@YAXPEAX@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	c2 00 00	 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.30.30705\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 123  :         explicit __CLR_OR_THIS_CALL operator bool() const {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C7C7F838_ostream
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 124  :             return _Ok;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]

; 125  :         }

  0002a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00031	5f		 pop	 rdi
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.30.30705\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Zero_uncaught_exceptions$ = 4
tv72 = 212
this$ = 256
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 108  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C7C7F838_ostream
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 109  : #if !_HAS_EXCEPTIONS
; 110  :             const bool _Zero_uncaught_exceptions = true;
; 111  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 112  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  0001f	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  00024	0f b6 c0	 movzx	 eax, al
  00027	85 c0		 test	 eax, eax
  00029	75 09		 jne	 SHORT $LN4@sentry
  0002b	c6 85 d4 00 00
	00 01		 mov	 BYTE PTR tv72[rbp], 1
  00032	eb 07		 jmp	 SHORT $LN5@sentry
$LN4@sentry:
  00034	c6 85 d4 00 00
	00 00		 mov	 BYTE PTR tv72[rbp], 0
$LN5@sentry:
  0003b	0f b6 85 d4 00
	00 00		 movzx	 eax, BYTE PTR tv72[rbp]
  00042	88 45 04	 mov	 BYTE PTR _Zero_uncaught_exceptions$[rbp], al

; 113  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 114  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 115  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 116  : 
; 117  :             if (_Zero_uncaught_exceptions) {

  00045	0f b6 45 04	 movzx	 eax, BYTE PTR _Zero_uncaught_exceptions$[rbp]
  00049	85 c0		 test	 eax, eax
  0004b	74 10		 je	 SHORT $LN2@sentry

; 118  :                 this->_Myostr._Osfx();

  0004d	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00054	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
$LN2@sentry:

; 119  :             }
; 120  :         }

  0005d	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00064	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00069	90		 npad	 1
  0006a	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00071	5f		 pop	 rdi
  00072	5d		 pop	 rbp
  00073	c3		 ret	 0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.30.30705\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
_Tied$ = 8
this$ = 256
_Ostr$ = 264
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 91   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C7C7F838_ostream
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00024	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR _Ostr$[rbp]
  0002b	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00032	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00037	90		 npad	 1

; 92   :             if (!_Ostr.good()) {

  00038	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  0003f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00042	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00046	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  0004d	48 03 c8	 add	 rcx, rax
  00050	48 8b c1	 mov	 rax, rcx
  00053	48 8b c8	 mov	 rcx, rax
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
  0005c	0f b6 c0	 movzx	 eax, al
  0005f	85 c0		 test	 eax, eax
  00061	75 10		 jne	 SHORT $LN2@sentry

; 93   :                 _Ok = false;

  00063	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0006a	c6 40 08 00	 mov	 BYTE PTR [rax+8], 0

; 94   :                 return;

  0006e	e9 81 00 00 00	 jmp	 $LN1@sentry
$LN2@sentry:

; 95   :             }
; 96   : 
; 97   :             const auto _Tied = _Ostr.tie();

  00073	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  0007a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007d	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00081	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00088	48 03 c8	 add	 rcx, rax
  0008b	48 8b c1	 mov	 rax, rcx
  0008e	48 8b c8	 mov	 rcx, rax
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  00097	48 89 45 08	 mov	 QWORD PTR _Tied$[rbp], rax

; 98   :             if (!_Tied || _Tied == &_Ostr) {

  0009b	48 83 7d 08 00	 cmp	 QWORD PTR _Tied$[rbp], 0
  000a0	74 0d		 je	 SHORT $LN4@sentry
  000a2	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  000a9	48 39 45 08	 cmp	 QWORD PTR _Tied$[rbp], rax
  000ad	75 0d		 jne	 SHORT $LN3@sentry
$LN4@sentry:

; 99   :                 _Ok = true;

  000af	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000b6	c6 40 08 01	 mov	 BYTE PTR [rax+8], 1

; 100  :                 return;

  000ba	eb 38		 jmp	 SHORT $LN1@sentry
$LN3@sentry:

; 101  :             }
; 102  : 
; 103  :             _Tied->flush();

  000bc	48 8b 4d 08	 mov	 rcx, QWORD PTR _Tied$[rbp]
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 104  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000c6	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  000cd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d0	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  000d4	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  000db	48 03 c8	 add	 rcx, rax
  000de	48 8b c1	 mov	 rax, rcx
  000e1	48 8b c8	 mov	 rcx, rax
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
  000ea	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	88 41 08	 mov	 BYTE PTR [rcx+8], al
$LN1@sentry:

; 105  :         }

  000f4	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  000fb	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00102	5f		 pop	 rdi
  00103	5d		 pop	 rbp
  00104	c3		 ret	 0
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
_Tied$ = 8
this$ = 256
_Ostr$ = 264
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  00014	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0001b	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	5f		 pop	 rdi
  00025	5d		 pop	 rbp
  00026	c3		 ret	 0
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.30.30705\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Rdbuf$ = 8
tv72 = 216
this$ = 256
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 77   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C7C7F838_ostream
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 78   :             const auto _Rdbuf = _Myostr.rdbuf();

  0001f	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	48 89 85 d8 00
	00 00		 mov	 QWORD PTR tv72[rbp], rax
  00030	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR tv72[rbp]
  00037	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003a	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0003e	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR tv72[rbp]
  00045	48 03 c8	 add	 rcx, rax
  00048	48 8b c1	 mov	 rax, rcx
  0004b	48 8b c8	 mov	 rcx, rax
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00054	48 89 45 08	 mov	 QWORD PTR _Rdbuf$[rbp], rax

; 79   :             if (_Rdbuf) {

  00058	48 83 7d 08 00	 cmp	 QWORD PTR _Rdbuf$[rbp], 0
  0005d	74 0f		 je	 SHORT $LN2@Sentry_bas

; 80   :                 _Rdbuf->_Unlock();

  0005f	48 8b 45 08	 mov	 rax, QWORD PTR _Rdbuf$[rbp]
  00063	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00066	48 8b 4d 08	 mov	 rcx, QWORD PTR _Rdbuf$[rbp]
  0006a	ff 50 10	 call	 QWORD PTR [rax+16]
  0006d	90		 npad	 1
$LN2@Sentry_bas:

; 81   :             }
; 82   :         }

  0006e	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00075	5f		 pop	 rdi
  00076	5d		 pop	 rbp
  00077	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.30.30705\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
_Rdbuf$ = 8
tv73 = 216
this$ = 256
_Ostr$ = 264
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 70   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C7C7F838_ostream
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00024	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00032	48 89 08	 mov	 QWORD PTR [rax], rcx

; 71   :             const auto _Rdbuf = _Myostr.rdbuf();

  00035	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0003c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003f	48 89 85 d8 00
	00 00		 mov	 QWORD PTR tv73[rbp], rax
  00046	48 8b 85 d8 00
	00 00		 mov	 rax, QWORD PTR tv73[rbp]
  0004d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00050	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00054	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR tv73[rbp]
  0005b	48 03 c8	 add	 rcx, rax
  0005e	48 8b c1	 mov	 rax, rcx
  00061	48 8b c8	 mov	 rcx, rax
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0006a	48 89 45 08	 mov	 QWORD PTR _Rdbuf$[rbp], rax

; 72   :             if (_Rdbuf) {

  0006e	48 83 7d 08 00	 cmp	 QWORD PTR _Rdbuf$[rbp], 0
  00073	74 0e		 je	 SHORT $LN2@Sentry_bas

; 73   :                 _Rdbuf->_Lock();

  00075	48 8b 45 08	 mov	 rax, QWORD PTR _Rdbuf$[rbp]
  00079	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007c	48 8b 4d 08	 mov	 rcx, QWORD PTR _Rdbuf$[rbp]
  00080	ff 50 08	 call	 QWORD PTR [rax+8]
$LN2@Sentry_bas:

; 74   :             }
; 75   :         }

  00083	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008a	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00091	5f		 pop	 rdi
  00092	5d		 pop	 rbp
  00093	c3		 ret	 0
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.30.30705\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z
_TEXT	SEGMENT
_State$ = 4
_Ok$ = 40
_Pad$4 = 88
$T5 = 308
$T6 = 340
$T7 = 372
$T8 = 404
$T9 = 436
$T10 = 468
$T11 = 504
tv289 = 516
tv284 = 516
tv65 = 516
tv290 = 520
tv287 = 520
tv285 = 520
tv130 = 520
tv291 = 528
tv288 = 528
tv286 = 528
__$ArrayPad$ = 536
_Ostr$ = 576
_Ch$ = 584
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 776  :     basic_ostream<char, _Traits>& _Ostr, char _Ch) { // insert a char into char stream

$LN23:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 48 02
	00 00		 sub	 rsp, 584		; 00000248H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001c	b9 5a 00 00 00	 mov	 ecx, 90			; 0000005aH
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR [rsp+616]
  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00037	48 33 c5	 xor	 rax, rbp
  0003a	48 89 85 18 02
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__C7C7F838_ostream
  00048	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 777  :     using _Elem = char;
; 778  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 779  : 
; 780  :     ios_base::iostate _State = ios_base::goodbit;

  0004d	c7 45 04 00 00
	00 00		 mov	 DWORD PTR _State$[rbp], 0

; 781  :     const typename _Myos::sentry _Ok(_Ostr);

  00054	48 8b 95 40 02
	00 00		 mov	 rdx, QWORD PTR _Ostr$[rbp]
  0005b	48 8d 4d 28	 lea	 rcx, QWORD PTR _Ok$[rbp]
  0005f	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  00064	90		 npad	 1

; 782  : 
; 783  :     if (_Ok) { // state okay, insert

  00065	48 8d 4d 28	 lea	 rcx, QWORD PTR _Ok$[rbp]
  00069	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  0006e	0f b6 c0	 movzx	 eax, al
  00071	85 c0		 test	 eax, eax
  00073	0f 84 d5 02 00
	00		 je	 $LN8@operator

; 784  :         streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

  00079	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00080	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00083	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00087	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  0008e	48 03 c8	 add	 rcx, rax
  00091	48 8b c1	 mov	 rax, rcx
  00094	48 8b c8	 mov	 rcx, rax
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  0009d	48 83 f8 01	 cmp	 rax, 1
  000a1	7f 0d		 jg	 SHORT $LN15@operator
  000a3	48 c7 85 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR tv130[rbp], 0
  000ae	eb 2e		 jmp	 SHORT $LN16@operator
$LN15@operator:
  000b0	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  000b7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ba	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  000be	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  000c5	48 03 c8	 add	 rcx, rax
  000c8	48 8b c1	 mov	 rax, rcx
  000cb	48 8b c8	 mov	 rcx, rax
  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
  000d4	48 ff c8	 dec	 rax
  000d7	48 89 85 08 02
	00 00		 mov	 QWORD PTR tv130[rbp], rax
$LN16@operator:
  000de	48 8b 85 08 02
	00 00		 mov	 rax, QWORD PTR tv130[rbp]
  000e5	48 89 45 58	 mov	 QWORD PTR _Pad$4[rbp], rax

; 785  : 
; 786  :         _TRY_IO_BEGIN
; 787  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  000e9	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  000f0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000f3	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  000f7	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  000fe	48 03 c8	 add	 rcx, rax
  00101	48 8b c1	 mov	 rax, rcx
  00104	48 8b c8	 mov	 rcx, rax
  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flags@ios_base@std@@QEBAHXZ
  0010d	89 85 04 02 00
	00		 mov	 DWORD PTR tv65[rbp], eax
  00113	8b 85 04 02 00
	00		 mov	 eax, DWORD PTR tv65[rbp]
  00119	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  0011e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00121	0f 84 d0 00 00
	00		 je	 $LN10@operator

; 788  :             for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on left

  00127	eb 0b		 jmp	 SHORT $LN4@operator
$LN2@operator:
  00129	48 8b 45 58	 mov	 rax, QWORD PTR _Pad$4[rbp]
  0012d	48 ff c8	 dec	 rax
  00130	48 89 45 58	 mov	 QWORD PTR _Pad$4[rbp], rax
$LN4@operator:
  00134	83 7d 04 00	 cmp	 DWORD PTR _State$[rbp], 0
  00138	0f 85 b9 00 00
	00		 jne	 $LN10@operator
  0013e	48 83 7d 58 00	 cmp	 QWORD PTR _Pad$4[rbp], 0
  00143	0f 8e ae 00 00
	00		 jle	 $LN10@operator

; 789  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00149	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00150	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00153	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00157	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  0015e	48 03 c8	 add	 rcx, rax
  00161	48 8b c1	 mov	 rax, rcx
  00164	48 8b c8	 mov	 rcx, rax
  00167	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
  0016d	88 85 04 02 00
	00		 mov	 BYTE PTR tv284[rbp], al
  00173	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  0017a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0017d	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00181	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00188	48 03 c8	 add	 rcx, rax
  0018b	48 8b c1	 mov	 rax, rcx
  0018e	48 8b c8	 mov	 rcx, rax
  00191	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00197	48 89 85 08 02
	00 00		 mov	 QWORD PTR tv285[rbp], rax
  0019e	0f b6 95 04 02
	00 00		 movzx	 edx, BYTE PTR tv284[rbp]
  001a5	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR tv285[rbp]
  001ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  001b2	89 85 10 02 00
	00		 mov	 DWORD PTR tv286[rbp], eax
  001b8	8b 85 10 02 00
	00		 mov	 eax, DWORD PTR tv286[rbp]
  001be	89 85 34 01 00
	00		 mov	 DWORD PTR $T5[rbp], eax
  001c4	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  001c9	89 85 54 01 00
	00		 mov	 DWORD PTR $T6[rbp], eax
  001cf	48 8d 95 34 01
	00 00		 lea	 rdx, QWORD PTR $T5[rbp]
  001d6	48 8d 8d 54 01
	00 00		 lea	 rcx, QWORD PTR $T6[rbp]
  001dd	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  001e2	0f b6 c0	 movzx	 eax, al
  001e5	85 c0		 test	 eax, eax
  001e7	74 09		 je	 SHORT $LN11@operator

; 790  :                     _State |= ios_base::badbit;

  001e9	8b 45 04	 mov	 eax, DWORD PTR _State$[rbp]
  001ec	83 c8 04	 or	 eax, 4
  001ef	89 45 04	 mov	 DWORD PTR _State$[rbp], eax
$LN11@operator:

; 791  :                 }
; 792  :             }

  001f2	e9 32 ff ff ff	 jmp	 $LN2@operator
$LN10@operator:

; 793  :         }
; 794  : 
; 795  :         if (_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch))) {

  001f7	83 7d 04 00	 cmp	 DWORD PTR _State$[rbp], 0
  001fb	75 7f		 jne	 SHORT $LN12@operator
  001fd	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00204	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00207	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0020b	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00212	48 03 c8	 add	 rcx, rax
  00215	48 8b c1	 mov	 rax, rcx
  00218	48 8b c8	 mov	 rcx, rax
  0021b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00221	48 89 85 08 02
	00 00		 mov	 QWORD PTR tv287[rbp], rax
  00228	0f b6 95 48 02
	00 00		 movzx	 edx, BYTE PTR _Ch$[rbp]
  0022f	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR tv287[rbp]
  00236	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  0023c	89 85 10 02 00
	00		 mov	 DWORD PTR tv288[rbp], eax
  00242	8b 85 10 02 00
	00		 mov	 eax, DWORD PTR tv288[rbp]
  00248	89 85 74 01 00
	00		 mov	 DWORD PTR $T7[rbp], eax
  0024e	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00253	89 85 94 01 00
	00		 mov	 DWORD PTR $T8[rbp], eax
  00259	48 8d 95 74 01
	00 00		 lea	 rdx, QWORD PTR $T7[rbp]
  00260	48 8d 8d 94 01
	00 00		 lea	 rcx, QWORD PTR $T8[rbp]
  00267	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  0026c	0f b6 c0	 movzx	 eax, al
  0026f	85 c0		 test	 eax, eax
  00271	74 09		 je	 SHORT $LN12@operator

; 796  :             _State |= ios_base::badbit;

  00273	8b 45 04	 mov	 eax, DWORD PTR _State$[rbp]
  00276	83 c8 04	 or	 eax, 4
  00279	89 45 04	 mov	 DWORD PTR _State$[rbp], eax
$LN12@operator:

; 797  :         }
; 798  : 
; 799  :         for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on right

  0027c	eb 0b		 jmp	 SHORT $LN7@operator
$LN5@operator:
  0027e	48 8b 45 58	 mov	 rax, QWORD PTR _Pad$4[rbp]
  00282	48 ff c8	 dec	 rax
  00285	48 89 45 58	 mov	 QWORD PTR _Pad$4[rbp], rax
$LN7@operator:
  00289	83 7d 04 00	 cmp	 DWORD PTR _State$[rbp], 0
  0028d	0f 85 b9 00 00
	00		 jne	 $LN6@operator
  00293	48 83 7d 58 00	 cmp	 QWORD PTR _Pad$4[rbp], 0
  00298	0f 8e ae 00 00
	00		 jle	 $LN6@operator

; 800  :             if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0029e	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  002a5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002a8	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  002ac	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  002b3	48 03 c8	 add	 rcx, rax
  002b6	48 8b c1	 mov	 rax, rcx
  002b9	48 8b c8	 mov	 rcx, rax
  002bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
  002c2	88 85 04 02 00
	00		 mov	 BYTE PTR tv289[rbp], al
  002c8	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  002cf	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002d2	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  002d6	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  002dd	48 03 c8	 add	 rcx, rax
  002e0	48 8b c1	 mov	 rax, rcx
  002e3	48 8b c8	 mov	 rcx, rax
  002e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  002ec	48 89 85 08 02
	00 00		 mov	 QWORD PTR tv290[rbp], rax
  002f3	0f b6 95 04 02
	00 00		 movzx	 edx, BYTE PTR tv289[rbp]
  002fa	48 8b 8d 08 02
	00 00		 mov	 rcx, QWORD PTR tv290[rbp]
  00301	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  00307	89 85 10 02 00
	00		 mov	 DWORD PTR tv291[rbp], eax
  0030d	8b 85 10 02 00
	00		 mov	 eax, DWORD PTR tv291[rbp]
  00313	89 85 b4 01 00
	00		 mov	 DWORD PTR $T9[rbp], eax
  00319	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0031e	89 85 d4 01 00
	00		 mov	 DWORD PTR $T10[rbp], eax
  00324	48 8d 95 b4 01
	00 00		 lea	 rdx, QWORD PTR $T9[rbp]
  0032b	48 8d 8d d4 01
	00 00		 lea	 rcx, QWORD PTR $T10[rbp]
  00332	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00337	0f b6 c0	 movzx	 eax, al
  0033a	85 c0		 test	 eax, eax
  0033c	74 09		 je	 SHORT $LN13@operator

; 801  :                 _State |= ios_base::badbit;

  0033e	8b 45 04	 mov	 eax, DWORD PTR _State$[rbp]
  00341	83 c8 04	 or	 eax, 4
  00344	89 45 04	 mov	 DWORD PTR _State$[rbp], eax
$LN13@operator:

; 802  :             }
; 803  :         }

  00347	e9 32 ff ff ff	 jmp	 $LN5@operator
$LN6@operator:
  0034c	eb 00		 jmp	 SHORT $LN8@operator
$LN21@operator:
$LN8@operator:

; 804  :         _CATCH_IO_(ios_base, _Ostr)
; 805  :     }
; 806  : 
; 807  :     _Ostr.width(0);

  0034e	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  00355	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00358	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0035c	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00363	48 03 c8	 add	 rcx, rax
  00366	48 8b c1	 mov	 rax, rcx
  00369	33 d2		 xor	 edx, edx
  0036b	48 8b c8	 mov	 rcx, rax
  0036e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?width@ios_base@std@@QEAA_J_J@Z

; 808  :     _Ostr.setstate(_State);

  00374	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  0037b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0037e	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00382	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00389	48 03 c8	 add	 rcx, rax
  0038c	48 8b c1	 mov	 rax, rcx
  0038f	45 33 c0	 xor	 r8d, r8d
  00392	8b 55 04	 mov	 edx, DWORD PTR _State$[rbp]
  00395	48 8b c8	 mov	 rcx, rax
  00398	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 809  :     return _Ostr;

  0039e	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  003a5	48 89 85 f8 01
	00 00		 mov	 QWORD PTR $T11[rbp], rax
  003ac	48 8d 4d 28	 lea	 rcx, QWORD PTR _Ok$[rbp]
  003b0	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  003b5	48 8b 85 f8 01
	00 00		 mov	 rax, QWORD PTR $T11[rbp]

; 810  : }

  003bc	48 8b f8	 mov	 rdi, rax
  003bf	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  003c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z$rtcFrameData
  003ca	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  003cf	48 8b c7	 mov	 rax, rdi
  003d2	48 8b 8d 18 02
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  003d9	48 33 cd	 xor	 rcx, rbp
  003dc	e8 00 00 00 00	 call	 __security_check_cookie
  003e1	48 8d a5 28 02
	00 00		 lea	 rsp, QWORD PTR [rbp+552]
  003e8	5f		 pop	 rdi
  003e9	5d		 pop	 rbp
  003ea	c3		 ret	 0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
_State$ = 4
_Ok$ = 40
_Pad$4 = 88
$T5 = 308
$T6 = 340
$T7 = 372
$T8 = 404
$T9 = 436
$T10 = 468
$T11 = 504
tv289 = 516
tv284 = 516
tv65 = 516
tv290 = 520
tv287 = 520
tv285 = 520
tv130 = 520
tv291 = 528
tv288 = 528
tv286 = 528
__$ArrayPad$ = 536
_Ostr$ = 576
_Ch$ = 584
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
  00014	48 8d 4d 28	 lea	 rcx, QWORD PTR _Ok$[rbp]
  00018	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	5f		 pop	 rdi
  00022	5d		 pop	 rbp
  00023	c3		 ret	 0
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
_State$ = 4
_Ok$ = 40
_Pad$4 = 88
$T5 = 308
$T6 = 340
$T7 = 372
$T8 = 404
$T9 = 436
$T10 = 468
$T11 = 504
tv289 = 516
tv284 = 516
tv65 = 516
tv290 = 520
tv287 = 520
tv285 = 520
tv130 = 520
tv291 = 528
tv288 = 528
tv286 = 528
__$ArrayPad$ = 536
_Ostr$ = 576
_Ch$ = 584
?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$1

; 804  :         _CATCH_IO_(ios_base, _Ostr)

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8d 6a 20	 lea	 rbp, QWORD PTR [rdx+32]
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z$0:
  00014	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR _Ostr$[rbp]
  0001b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001e	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00022	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR _Ostr$[rbp]
  00029	48 03 c8	 add	 rcx, rax
  0002c	48 8b c1	 mov	 rax, rcx
  0002f	41 b0 01	 mov	 r8b, 1
  00032	ba 04 00 00 00	 mov	 edx, 4
  00037	48 8b c8	 mov	 rcx, rax
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00040	90		 npad	 1
  00041	48 8d 05 00 00
	00 00		 lea	 rax, $LN21@catch$1
  00048	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004c	5f		 pop	 rdi
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
  0004f	cc		 int	 3
?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\shchi\BSUIR\C++ 1 sem\Sorts\Sorts\Sorts.cpp
;	COMDAT main
_TEXT	SEGMENT
main	PROC						; COMDAT

; 15   : {

$LN3:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7D9C9A72_Sorts@cpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 16   : 	
; 17   : 		std::cout << __cplusplus;

  0001b	ba 1f 0c 03 00	 mov	 edx, 199711		; 00030c1fH
  00020	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z

; 18   : 	
; 19   : }

  0002d	33 c0		 xor	 eax, eax
  0002f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00036	5f		 pop	 rdi
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\shchi\BSUIR\C++ 1 sem\Sorts\Sorts\Sorts.cpp
;	COMDAT ?code@@YAXPEBD@Z
_TEXT	SEGMENT
str$ = 224
?code@@YAXPEBD@Z PROC					; code, COMDAT

; 23   : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7D9C9A72_Sorts@cpp
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN2@code:

; 24   : 	while (*str) {

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR str$[rbp]
  00026	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00029	85 c0		 test	 eax, eax
  0002b	74 2e		 je	 SHORT $LN3@code

; 25   : 		cout << (char)(*str + 1);

  0002d	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR str$[rbp]
  00034	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00037	ff c0		 inc	 eax
  00039	0f b6 d0	 movzx	 edx, al
  0003c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00043	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 26   : 		str++;

  00048	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR str$[rbp]
  0004f	48 ff c0	 inc	 rax
  00052	48 89 85 e0 00
	00 00		 mov	 QWORD PTR str$[rbp], rax

; 27   : 	}

  00059	eb c4		 jmp	 SHORT $LN2@code
$LN3@code:

; 28   : }

  0005b	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00062	5f		 pop	 rdi
  00063	5d		 pop	 rbp
  00064	c3		 ret	 0
?code@@YAXPEBD@Z ENDP					; code
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\shchi\BSUIR\C++ 1 sem\Sorts\Sorts\Sorts.cpp
;	COMDAT ?BubleSort@@YAXHQEAH@Z
_TEXT	SEGMENT
temp$ = 4
i$1 = 36
j$2 = 68
n$ = 320
arr$ = 328
?BubleSort@@YAXHQEAH@Z PROC				; BubleSort, COMDAT

; 31   : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7D9C9A72_Sorts@cpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 32   : 	int temp = 0;

  00023	c7 45 04 00 00
	00 00		 mov	 DWORD PTR temp$[rbp], 0

; 33   : 	for (int i = 0; i < n - 1; i++)

  0002a	c7 45 24 00 00
	00 00		 mov	 DWORD PTR i$1[rbp], 0
  00031	eb 08		 jmp	 SHORT $LN4@BubleSort
$LN2@BubleSort:
  00033	8b 45 24	 mov	 eax, DWORD PTR i$1[rbp]
  00036	ff c0		 inc	 eax
  00038	89 45 24	 mov	 DWORD PTR i$1[rbp], eax
$LN4@BubleSort:
  0003b	8b 85 40 01 00
	00		 mov	 eax, DWORD PTR n$[rbp]
  00041	ff c8		 dec	 eax
  00043	39 45 24	 cmp	 DWORD PTR i$1[rbp], eax
  00046	0f 8d 97 00 00
	00		 jge	 $LN3@BubleSort

; 34   : 	{
; 35   : 		for (int j = 0; j < n - i - 1; j++)

  0004c	c7 45 44 00 00
	00 00		 mov	 DWORD PTR j$2[rbp], 0
  00053	eb 08		 jmp	 SHORT $LN7@BubleSort
$LN5@BubleSort:
  00055	8b 45 44	 mov	 eax, DWORD PTR j$2[rbp]
  00058	ff c0		 inc	 eax
  0005a	89 45 44	 mov	 DWORD PTR j$2[rbp], eax
$LN7@BubleSort:
  0005d	8b 45 24	 mov	 eax, DWORD PTR i$1[rbp]
  00060	8b 8d 40 01 00
	00		 mov	 ecx, DWORD PTR n$[rbp]
  00066	2b c8		 sub	 ecx, eax
  00068	8b c1		 mov	 eax, ecx
  0006a	ff c8		 dec	 eax
  0006c	39 45 44	 cmp	 DWORD PTR j$2[rbp], eax
  0006f	7d 6d		 jge	 SHORT $LN6@BubleSort

; 36   : 		{
; 37   : 			if (arr[j] < arr[j + 1])

  00071	48 63 45 44	 movsxd	 rax, DWORD PTR j$2[rbp]
  00075	8b 4d 44	 mov	 ecx, DWORD PTR j$2[rbp]
  00078	ff c1		 inc	 ecx
  0007a	48 63 c9	 movsxd	 rcx, ecx
  0007d	48 8b 95 48 01
	00 00		 mov	 rdx, QWORD PTR arr$[rbp]
  00084	4c 8b 85 48 01
	00 00		 mov	 r8, QWORD PTR arr$[rbp]
  0008b	41 8b 0c 88	 mov	 ecx, DWORD PTR [r8+rcx*4]
  0008f	39 0c 82	 cmp	 DWORD PTR [rdx+rax*4], ecx
  00092	7d 45		 jge	 SHORT $LN8@BubleSort

; 38   : 			{
; 39   : 				temp = arr[j];

  00094	48 63 45 44	 movsxd	 rax, DWORD PTR j$2[rbp]
  00098	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR arr$[rbp]
  0009f	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000a2	89 45 04	 mov	 DWORD PTR temp$[rbp], eax

; 40   : 				arr[j] = arr[j + 1];

  000a5	8b 45 44	 mov	 eax, DWORD PTR j$2[rbp]
  000a8	ff c0		 inc	 eax
  000aa	48 98		 cdqe
  000ac	48 63 4d 44	 movsxd	 rcx, DWORD PTR j$2[rbp]
  000b0	48 8b 95 48 01
	00 00		 mov	 rdx, QWORD PTR arr$[rbp]
  000b7	4c 8b 85 48 01
	00 00		 mov	 r8, QWORD PTR arr$[rbp]
  000be	41 8b 04 80	 mov	 eax, DWORD PTR [r8+rax*4]
  000c2	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 41   : 				arr[j + 1] = temp;

  000c5	8b 45 44	 mov	 eax, DWORD PTR j$2[rbp]
  000c8	ff c0		 inc	 eax
  000ca	48 98		 cdqe
  000cc	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR arr$[rbp]
  000d3	8b 55 04	 mov	 edx, DWORD PTR temp$[rbp]
  000d6	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
$LN8@BubleSort:

; 42   : 			}
; 43   : 		}

  000d9	e9 77 ff ff ff	 jmp	 $LN5@BubleSort
$LN6@BubleSort:

; 44   : 	}

  000de	e9 50 ff ff ff	 jmp	 $LN2@BubleSort
$LN3@BubleSort:

; 45   : }

  000e3	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  000ea	5f		 pop	 rdi
  000eb	5d		 pop	 rbp
  000ec	c3		 ret	 0
?BubleSort@@YAXHQEAH@Z ENDP				; BubleSort
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\shchi\BSUIR\C++ 1 sem\Sorts\Sorts\Sorts.cpp
;	COMDAT ?ShellSort@@YAXHQEAH@Z
_TEXT	SEGMENT
j$ = 36
temp$ = 68
step$1 = 100
i$2 = 132
n$ = 384
arr$ = 392
?ShellSort@@YAXHQEAH@Z PROC				; ShellSort, COMDAT

; 118  : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7D9C9A72_Sorts@cpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 119  : 	int i, j, temp;
; 120  : 	for (int step = n / 2; step > 0; step /= 2)

  00023	8b 85 80 01 00
	00		 mov	 eax, DWORD PTR n$[rbp]
  00029	99		 cdq
  0002a	2b c2		 sub	 eax, edx
  0002c	d1 f8		 sar	 eax, 1
  0002e	89 45 64	 mov	 DWORD PTR step$1[rbp], eax
  00031	eb 0b		 jmp	 SHORT $LN4@ShellSort
$LN2@ShellSort:
  00033	8b 45 64	 mov	 eax, DWORD PTR step$1[rbp]
  00036	99		 cdq
  00037	2b c2		 sub	 eax, edx
  00039	d1 f8		 sar	 eax, 1
  0003b	89 45 64	 mov	 DWORD PTR step$1[rbp], eax
$LN4@ShellSort:
  0003e	83 7d 64 00	 cmp	 DWORD PTR step$1[rbp], 0
  00042	0f 8e be 00 00
	00		 jle	 $LN3@ShellSort

; 121  : 	{
; 122  : 		for (int i = step; i < n; i++)

  00048	8b 45 64	 mov	 eax, DWORD PTR step$1[rbp]
  0004b	89 85 84 00 00
	00		 mov	 DWORD PTR i$2[rbp], eax
  00051	eb 0e		 jmp	 SHORT $LN7@ShellSort
$LN5@ShellSort:
  00053	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$2[rbp]
  00059	ff c0		 inc	 eax
  0005b	89 85 84 00 00
	00		 mov	 DWORD PTR i$2[rbp], eax
$LN7@ShellSort:
  00061	8b 85 80 01 00
	00		 mov	 eax, DWORD PTR n$[rbp]
  00067	39 85 84 00 00
	00		 cmp	 DWORD PTR i$2[rbp], eax
  0006d	0f 8d 8e 00 00
	00		 jge	 $LN6@ShellSort

; 123  : 		{
; 124  : 			temp = arr[i];

  00073	48 63 85 84 00
	00 00		 movsxd	 rax, DWORD PTR i$2[rbp]
  0007a	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR arr$[rbp]
  00081	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00084	89 45 44	 mov	 DWORD PTR temp$[rbp], eax

; 125  : 			for (j = i; j >= step; j -= step)

  00087	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$2[rbp]
  0008d	89 45 24	 mov	 DWORD PTR j$[rbp], eax
  00090	eb 0d		 jmp	 SHORT $LN10@ShellSort
$LN8@ShellSort:
  00092	8b 45 64	 mov	 eax, DWORD PTR step$1[rbp]
  00095	8b 4d 24	 mov	 ecx, DWORD PTR j$[rbp]
  00098	2b c8		 sub	 ecx, eax
  0009a	8b c1		 mov	 eax, ecx
  0009c	89 45 24	 mov	 DWORD PTR j$[rbp], eax
$LN10@ShellSort:
  0009f	8b 45 64	 mov	 eax, DWORD PTR step$1[rbp]
  000a2	39 45 24	 cmp	 DWORD PTR j$[rbp], eax
  000a5	7c 44		 jl	 SHORT $LN9@ShellSort

; 126  : 			{
; 127  : 				if (temp >= arr[j - step])

  000a7	8b 45 64	 mov	 eax, DWORD PTR step$1[rbp]
  000aa	8b 4d 24	 mov	 ecx, DWORD PTR j$[rbp]
  000ad	2b c8		 sub	 ecx, eax
  000af	8b c1		 mov	 eax, ecx
  000b1	48 98		 cdqe
  000b3	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR arr$[rbp]
  000ba	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000bd	39 45 44	 cmp	 DWORD PTR temp$[rbp], eax
  000c0	7c 02		 jl	 SHORT $LN11@ShellSort

; 128  : 				{
; 129  : 					break;

  000c2	eb 27		 jmp	 SHORT $LN9@ShellSort
$LN11@ShellSort:

; 130  : 				}
; 131  : 				arr[j] = arr[j - step];

  000c4	8b 45 64	 mov	 eax, DWORD PTR step$1[rbp]
  000c7	8b 4d 24	 mov	 ecx, DWORD PTR j$[rbp]
  000ca	2b c8		 sub	 ecx, eax
  000cc	8b c1		 mov	 eax, ecx
  000ce	48 98		 cdqe
  000d0	48 63 4d 24	 movsxd	 rcx, DWORD PTR j$[rbp]
  000d4	48 8b 95 88 01
	00 00		 mov	 rdx, QWORD PTR arr$[rbp]
  000db	4c 8b 85 88 01
	00 00		 mov	 r8, QWORD PTR arr$[rbp]
  000e2	41 8b 04 80	 mov	 eax, DWORD PTR [r8+rax*4]
  000e6	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 132  : 			}

  000e9	eb a7		 jmp	 SHORT $LN8@ShellSort
$LN9@ShellSort:

; 133  : 			arr[j] = temp;

  000eb	48 63 45 24	 movsxd	 rax, DWORD PTR j$[rbp]
  000ef	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR arr$[rbp]
  000f6	8b 55 44	 mov	 edx, DWORD PTR temp$[rbp]
  000f9	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx

; 134  : 		}

  000fc	e9 52 ff ff ff	 jmp	 $LN5@ShellSort
$LN6@ShellSort:

; 135  : 	}

  00101	e9 2d ff ff ff	 jmp	 $LN2@ShellSort
$LN3@ShellSort:

; 136  : }

  00106	48 8d a5 68 01
	00 00		 lea	 rsp, QWORD PTR [rbp+360]
  0010d	5f		 pop	 rdi
  0010e	5d		 pop	 rbp
  0010f	c3		 ret	 0
?ShellSort@@YAXHQEAH@Z ENDP				; ShellSort
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\shchi\BSUIR\C++ 1 sem\Sorts\Sorts\Sorts.cpp
;	COMDAT ?InsertSort@@YAXHQEAH@Z
_TEXT	SEGMENT
j$ = 4
temp$ = 36
i$1 = 68
n$ = 320
arr$ = 328
?InsertSort@@YAXHQEAH@Z PROC				; InsertSort, COMDAT

; 100  : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7D9C9A72_Sorts@cpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 101  : 	int j, temp;
; 102  : 	for (int i = 1; i < n; i++)

  00023	c7 45 44 01 00
	00 00		 mov	 DWORD PTR i$1[rbp], 1
  0002a	eb 08		 jmp	 SHORT $LN4@InsertSort
$LN2@InsertSort:
  0002c	8b 45 44	 mov	 eax, DWORD PTR i$1[rbp]
  0002f	ff c0		 inc	 eax
  00031	89 45 44	 mov	 DWORD PTR i$1[rbp], eax
$LN4@InsertSort:
  00034	8b 85 40 01 00
	00		 mov	 eax, DWORD PTR n$[rbp]
  0003a	39 45 44	 cmp	 DWORD PTR i$1[rbp], eax
  0003d	7d 7a		 jge	 SHORT $LN3@InsertSort

; 103  : 	{
; 104  : 		temp = arr[i];

  0003f	48 63 45 44	 movsxd	 rax, DWORD PTR i$1[rbp]
  00043	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR arr$[rbp]
  0004a	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0004d	89 45 24	 mov	 DWORD PTR temp$[rbp], eax

; 105  : 		for (j = i - 1; j >= 0; j--)

  00050	8b 45 44	 mov	 eax, DWORD PTR i$1[rbp]
  00053	ff c8		 dec	 eax
  00055	89 45 04	 mov	 DWORD PTR j$[rbp], eax
  00058	eb 08		 jmp	 SHORT $LN7@InsertSort
$LN5@InsertSort:
  0005a	8b 45 04	 mov	 eax, DWORD PTR j$[rbp]
  0005d	ff c8		 dec	 eax
  0005f	89 45 04	 mov	 DWORD PTR j$[rbp], eax
$LN7@InsertSort:
  00062	83 7d 04 00	 cmp	 DWORD PTR j$[rbp], 0
  00066	7c 38		 jl	 SHORT $LN6@InsertSort

; 106  : 		{
; 107  : 			if (arr[j] <= temp)

  00068	48 63 45 04	 movsxd	 rax, DWORD PTR j$[rbp]
  0006c	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR arr$[rbp]
  00073	8b 55 24	 mov	 edx, DWORD PTR temp$[rbp]
  00076	39 14 81	 cmp	 DWORD PTR [rcx+rax*4], edx
  00079	7f 02		 jg	 SHORT $LN8@InsertSort

; 108  : 			{
; 109  : 				break;

  0007b	eb 23		 jmp	 SHORT $LN6@InsertSort
$LN8@InsertSort:

; 110  : 			}
; 111  : 			arr[j + 1] = arr[j];

  0007d	48 63 45 04	 movsxd	 rax, DWORD PTR j$[rbp]
  00081	8b 4d 04	 mov	 ecx, DWORD PTR j$[rbp]
  00084	ff c1		 inc	 ecx
  00086	48 63 c9	 movsxd	 rcx, ecx
  00089	48 8b 95 48 01
	00 00		 mov	 rdx, QWORD PTR arr$[rbp]
  00090	4c 8b 85 48 01
	00 00		 mov	 r8, QWORD PTR arr$[rbp]
  00097	41 8b 04 80	 mov	 eax, DWORD PTR [r8+rax*4]
  0009b	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 112  : 		}

  0009e	eb ba		 jmp	 SHORT $LN5@InsertSort
$LN6@InsertSort:

; 113  : 		arr[j + 1] = temp;

  000a0	8b 45 04	 mov	 eax, DWORD PTR j$[rbp]
  000a3	ff c0		 inc	 eax
  000a5	48 98		 cdqe
  000a7	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR arr$[rbp]
  000ae	8b 55 24	 mov	 edx, DWORD PTR temp$[rbp]
  000b1	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx

; 114  : 	}

  000b4	e9 73 ff ff ff	 jmp	 $LN2@InsertSort
$LN3@InsertSort:

; 115  : }

  000b9	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  000c0	5f		 pop	 rdi
  000c1	5d		 pop	 rbp
  000c2	c3		 ret	 0
?InsertSort@@YAXHQEAH@Z ENDP				; InsertSort
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\shchi\BSUIR\C++ 1 sem\Sorts\Sorts\Sorts.cpp
;	COMDAT ?SelectionSort@@YAXHQEAH@Z
_TEXT	SEGMENT
min$ = 4
temp$ = 36
i$1 = 68
j$2 = 100
n$ = 352
arr$ = 360
?SelectionSort@@YAXHQEAH@Z PROC				; SelectionSort, COMDAT

; 81   : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7D9C9A72_Sorts@cpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 82   : 	int min, temp;
; 83   : 	for (int i = 0; i < n - 1; i++)

  00023	c7 45 44 00 00
	00 00		 mov	 DWORD PTR i$1[rbp], 0
  0002a	eb 08		 jmp	 SHORT $LN4@SelectionS
$LN2@SelectionS:
  0002c	8b 45 44	 mov	 eax, DWORD PTR i$1[rbp]
  0002f	ff c0		 inc	 eax
  00031	89 45 44	 mov	 DWORD PTR i$1[rbp], eax
$LN4@SelectionS:
  00034	8b 85 60 01 00
	00		 mov	 eax, DWORD PTR n$[rbp]
  0003a	ff c8		 dec	 eax
  0003c	39 45 44	 cmp	 DWORD PTR i$1[rbp], eax
  0003f	0f 8d 8e 00 00
	00		 jge	 $LN3@SelectionS

; 84   : 	{
; 85   : 		min = i;

  00045	8b 45 44	 mov	 eax, DWORD PTR i$1[rbp]
  00048	89 45 04	 mov	 DWORD PTR min$[rbp], eax

; 86   : 		for (int j = i + 1; j < n; j++)

  0004b	8b 45 44	 mov	 eax, DWORD PTR i$1[rbp]
  0004e	ff c0		 inc	 eax
  00050	89 45 64	 mov	 DWORD PTR j$2[rbp], eax
  00053	eb 08		 jmp	 SHORT $LN7@SelectionS
$LN5@SelectionS:
  00055	8b 45 64	 mov	 eax, DWORD PTR j$2[rbp]
  00058	ff c0		 inc	 eax
  0005a	89 45 64	 mov	 DWORD PTR j$2[rbp], eax
$LN7@SelectionS:
  0005d	8b 85 60 01 00
	00		 mov	 eax, DWORD PTR n$[rbp]
  00063	39 45 64	 cmp	 DWORD PTR j$2[rbp], eax
  00066	7d 27		 jge	 SHORT $LN6@SelectionS

; 87   : 		{
; 88   : 			if (arr[j] < arr[min])

  00068	48 63 45 64	 movsxd	 rax, DWORD PTR j$2[rbp]
  0006c	48 63 4d 04	 movsxd	 rcx, DWORD PTR min$[rbp]
  00070	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR arr$[rbp]
  00077	4c 8b 85 68 01
	00 00		 mov	 r8, QWORD PTR arr$[rbp]
  0007e	41 8b 0c 88	 mov	 ecx, DWORD PTR [r8+rcx*4]
  00082	39 0c 82	 cmp	 DWORD PTR [rdx+rax*4], ecx
  00085	7d 06		 jge	 SHORT $LN8@SelectionS

; 89   : 			{
; 90   : 				min = j;

  00087	8b 45 64	 mov	 eax, DWORD PTR j$2[rbp]
  0008a	89 45 04	 mov	 DWORD PTR min$[rbp], eax
$LN8@SelectionS:

; 91   : 			}
; 92   : 		}

  0008d	eb c6		 jmp	 SHORT $LN5@SelectionS
$LN6@SelectionS:

; 93   : 		temp = arr[i];

  0008f	48 63 45 44	 movsxd	 rax, DWORD PTR i$1[rbp]
  00093	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR arr$[rbp]
  0009a	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0009d	89 45 24	 mov	 DWORD PTR temp$[rbp], eax

; 94   : 		arr[i] = arr[min];

  000a0	48 63 45 04	 movsxd	 rax, DWORD PTR min$[rbp]
  000a4	48 63 4d 44	 movsxd	 rcx, DWORD PTR i$1[rbp]
  000a8	48 8b 95 68 01
	00 00		 mov	 rdx, QWORD PTR arr$[rbp]
  000af	4c 8b 85 68 01
	00 00		 mov	 r8, QWORD PTR arr$[rbp]
  000b6	41 8b 04 80	 mov	 eax, DWORD PTR [r8+rax*4]
  000ba	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 95   : 		arr[min] = temp;

  000bd	48 63 45 04	 movsxd	 rax, DWORD PTR min$[rbp]
  000c1	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR arr$[rbp]
  000c8	8b 55 24	 mov	 edx, DWORD PTR temp$[rbp]
  000cb	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx

; 96   : 	}

  000ce	e9 59 ff ff ff	 jmp	 $LN2@SelectionS
$LN3@SelectionS:

; 97   : }

  000d3	48 8d a5 48 01
	00 00		 lea	 rsp, QWORD PTR [rbp+328]
  000da	5f		 pop	 rdi
  000db	5d		 pop	 rbp
  000dc	c3		 ret	 0
?SelectionSort@@YAXHQEAH@Z ENDP				; SelectionSort
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\shchi\BSUIR\C++ 1 sem\Sorts\Sorts\Sorts.cpp
;	COMDAT ?ShakerSort@@YAXHQEAH@Z
_TEXT	SEGMENT
swap$ = 4
buff$ = 36
left$ = 68
right$ = 100
i$1 = 132
i$2 = 164
n$ = 416
arr$ = 424
?ShakerSort@@YAXHQEAH@Z PROC				; ShakerSort, COMDAT

; 48   : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec a8 01
	00 00		 sub	 rsp, 424		; 000001a8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7D9C9A72_Sorts@cpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 49   : 	bool swap = true;

  00023	c6 45 04 01	 mov	 BYTE PTR swap$[rbp], 1

; 50   : 	int buff = 0, left = 0, right = n - 1;

  00027	c7 45 24 00 00
	00 00		 mov	 DWORD PTR buff$[rbp], 0
  0002e	c7 45 44 00 00
	00 00		 mov	 DWORD PTR left$[rbp], 0
  00035	8b 85 a0 01 00
	00		 mov	 eax, DWORD PTR n$[rbp]
  0003b	ff c8		 dec	 eax
  0003d	89 45 64	 mov	 DWORD PTR right$[rbp], eax
$LN2@ShakerSort:

; 51   : 	while (swap && (left < right))

  00040	0f b6 45 04	 movzx	 eax, BYTE PTR swap$[rbp]
  00044	85 c0		 test	 eax, eax
  00046	0f 84 7a 01 00
	00		 je	 $LN3@ShakerSort
  0004c	8b 45 64	 mov	 eax, DWORD PTR right$[rbp]
  0004f	39 45 44	 cmp	 DWORD PTR left$[rbp], eax
  00052	0f 8d 6e 01 00
	00		 jge	 $LN3@ShakerSort

; 52   : 	{
; 53   : 		swap = false;

  00058	c6 45 04 00	 mov	 BYTE PTR swap$[rbp], 0

; 54   : 		for (int i = left; i < right; i++)

  0005c	8b 45 44	 mov	 eax, DWORD PTR left$[rbp]
  0005f	89 85 84 00 00
	00		 mov	 DWORD PTR i$1[rbp], eax
  00065	eb 0e		 jmp	 SHORT $LN6@ShakerSort
$LN4@ShakerSort:
  00067	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$1[rbp]
  0006d	ff c0		 inc	 eax
  0006f	89 85 84 00 00
	00		 mov	 DWORD PTR i$1[rbp], eax
$LN6@ShakerSort:
  00075	8b 45 64	 mov	 eax, DWORD PTR right$[rbp]
  00078	39 85 84 00 00
	00		 cmp	 DWORD PTR i$1[rbp], eax
  0007e	0f 8d 83 00 00
	00		 jge	 $LN5@ShakerSort

; 55   : 		{
; 56   : 			if (arr[i] > arr[i + 1])

  00084	48 63 85 84 00
	00 00		 movsxd	 rax, DWORD PTR i$1[rbp]
  0008b	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR i$1[rbp]
  00091	ff c1		 inc	 ecx
  00093	48 63 c9	 movsxd	 rcx, ecx
  00096	48 8b 95 a8 01
	00 00		 mov	 rdx, QWORD PTR arr$[rbp]
  0009d	4c 8b 85 a8 01
	00 00		 mov	 r8, QWORD PTR arr$[rbp]
  000a4	41 8b 0c 88	 mov	 ecx, DWORD PTR [r8+rcx*4]
  000a8	39 0c 82	 cmp	 DWORD PTR [rdx+rax*4], ecx
  000ab	7e 55		 jle	 SHORT $LN10@ShakerSort

; 57   : 			{
; 58   : 				buff = arr[i];

  000ad	48 63 85 84 00
	00 00		 movsxd	 rax, DWORD PTR i$1[rbp]
  000b4	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR arr$[rbp]
  000bb	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000be	89 45 24	 mov	 DWORD PTR buff$[rbp], eax

; 59   : 				arr[i] = arr[i + 1];

  000c1	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$1[rbp]
  000c7	ff c0		 inc	 eax
  000c9	48 98		 cdqe
  000cb	48 63 8d 84 00
	00 00		 movsxd	 rcx, DWORD PTR i$1[rbp]
  000d2	48 8b 95 a8 01
	00 00		 mov	 rdx, QWORD PTR arr$[rbp]
  000d9	4c 8b 85 a8 01
	00 00		 mov	 r8, QWORD PTR arr$[rbp]
  000e0	41 8b 04 80	 mov	 eax, DWORD PTR [r8+rax*4]
  000e4	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 60   : 				arr[i + 1] = buff;

  000e7	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$1[rbp]
  000ed	ff c0		 inc	 eax
  000ef	48 98		 cdqe
  000f1	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR arr$[rbp]
  000f8	8b 55 24	 mov	 edx, DWORD PTR buff$[rbp]
  000fb	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx

; 61   : 				swap = true;

  000fe	c6 45 04 01	 mov	 BYTE PTR swap$[rbp], 1
$LN10@ShakerSort:

; 62   : 			}
; 63   : 		}

  00102	e9 60 ff ff ff	 jmp	 $LN4@ShakerSort
$LN5@ShakerSort:

; 64   : 		right--;

  00107	8b 45 64	 mov	 eax, DWORD PTR right$[rbp]
  0010a	ff c8		 dec	 eax
  0010c	89 45 64	 mov	 DWORD PTR right$[rbp], eax

; 65   : 
; 66   : 		for (int i = right; i > left; i--)

  0010f	8b 45 64	 mov	 eax, DWORD PTR right$[rbp]
  00112	89 85 a4 00 00
	00		 mov	 DWORD PTR i$2[rbp], eax
  00118	eb 0e		 jmp	 SHORT $LN9@ShakerSort
$LN7@ShakerSort:
  0011a	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR i$2[rbp]
  00120	ff c8		 dec	 eax
  00122	89 85 a4 00 00
	00		 mov	 DWORD PTR i$2[rbp], eax
$LN9@ShakerSort:
  00128	8b 45 44	 mov	 eax, DWORD PTR left$[rbp]
  0012b	39 85 a4 00 00
	00		 cmp	 DWORD PTR i$2[rbp], eax
  00131	0f 8e 82 00 00
	00		 jle	 $LN8@ShakerSort

; 67   : 		{
; 68   : 			if (arr[i - 1] > arr[i])

  00137	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR i$2[rbp]
  0013d	ff c8		 dec	 eax
  0013f	48 98		 cdqe
  00141	48 63 8d a4 00
	00 00		 movsxd	 rcx, DWORD PTR i$2[rbp]
  00148	48 8b 95 a8 01
	00 00		 mov	 rdx, QWORD PTR arr$[rbp]
  0014f	4c 8b 85 a8 01
	00 00		 mov	 r8, QWORD PTR arr$[rbp]
  00156	41 8b 0c 88	 mov	 ecx, DWORD PTR [r8+rcx*4]
  0015a	39 0c 82	 cmp	 DWORD PTR [rdx+rax*4], ecx
  0015d	7e 55		 jle	 SHORT $LN11@ShakerSort

; 69   : 			{
; 70   : 				buff = arr[i];

  0015f	48 63 85 a4 00
	00 00		 movsxd	 rax, DWORD PTR i$2[rbp]
  00166	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR arr$[rbp]
  0016d	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00170	89 45 24	 mov	 DWORD PTR buff$[rbp], eax

; 71   : 				arr[i] = arr[i - 1];

  00173	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR i$2[rbp]
  00179	ff c8		 dec	 eax
  0017b	48 98		 cdqe
  0017d	48 63 8d a4 00
	00 00		 movsxd	 rcx, DWORD PTR i$2[rbp]
  00184	48 8b 95 a8 01
	00 00		 mov	 rdx, QWORD PTR arr$[rbp]
  0018b	4c 8b 85 a8 01
	00 00		 mov	 r8, QWORD PTR arr$[rbp]
  00192	41 8b 04 80	 mov	 eax, DWORD PTR [r8+rax*4]
  00196	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 72   : 				arr[i - 1] = buff;

  00199	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR i$2[rbp]
  0019f	ff c8		 dec	 eax
  001a1	48 98		 cdqe
  001a3	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR arr$[rbp]
  001aa	8b 55 24	 mov	 edx, DWORD PTR buff$[rbp]
  001ad	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx

; 73   : 				swap = true;

  001b0	c6 45 04 01	 mov	 BYTE PTR swap$[rbp], 1
$LN11@ShakerSort:

; 74   : 			}
; 75   : 		}

  001b4	e9 61 ff ff ff	 jmp	 $LN7@ShakerSort
$LN8@ShakerSort:

; 76   : 		left++;

  001b9	8b 45 44	 mov	 eax, DWORD PTR left$[rbp]
  001bc	ff c0		 inc	 eax
  001be	89 45 44	 mov	 DWORD PTR left$[rbp], eax

; 77   : 	}

  001c1	e9 7a fe ff ff	 jmp	 $LN2@ShakerSort
$LN3@ShakerSort:

; 78   : }

  001c6	48 8d a5 88 01
	00 00		 lea	 rsp, QWORD PTR [rbp+392]
  001cd	5f		 pop	 rdi
  001ce	5d		 pop	 rbp
  001cf	c3		 ret	 0
?ShakerSort@@YAXHQEAH@Z ENDP				; ShakerSort
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.30.30705\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 465  :     _NODISCARD static constexpr int_type eof() noexcept {

$LN3:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0BE956CD_xstring
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 466  :         return static_cast<int_type>(EOF);

  0001b	b8 ff ff ff ff	 mov	 eax, -1

; 467  :     }

  00020	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00027	5f		 pop	 rdi
  00028	5d		 pop	 rbp
  00029	c3		 ret	 0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.30.30705\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z
_TEXT	SEGMENT
tv65 = 192
_Left$ = 240
_Right$ = 248
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 457  :     _NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__0BE956CD_xstring
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 458  :         return _Left == _Right;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR _Left$[rbp]
  0002b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR _Right$[rbp]
  00032	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00034	39 08		 cmp	 DWORD PTR [rax], ecx
  00036	75 0c		 jne	 SHORT $LN3@eq_int_typ
  00038	c7 85 c0 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv65[rbp], 1
  00042	eb 0a		 jmp	 SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
  00044	c7 85 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv65[rbp], 0
$LN4@eq_int_typ:
  0004e	0f b6 85 c0 00
	00 00		 movzx	 eax, BYTE PTR tv65[rbp]

; 459  :     }

  00055	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0005c	5f		 pop	 rdi
  0005d	5d		 pop	 rbp
  0005e	c3		 ret	 0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\shchi\BSUIR\C++ 1 sem\Sorts\Sorts\Sorts.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX_K@Z
_TEXT	SEGMENT
__formal$ = 224
__formal$ = 232
?__empty_global_delete@@YAXPEAX_K@Z PROC		; __empty_global_delete, COMDAT

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7D9C9A72_Sorts@cpp
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00024	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0002b	5f		 pop	 rdi
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?__empty_global_delete@@YAXPEAX_K@Z ENDP		; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\shchi\BSUIR\C++ 1 sem\Sorts\Sorts\Sorts.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX@Z
_TEXT	SEGMENT
__formal$ = 224
?__empty_global_delete@@YAXPEAX@Z PROC			; __empty_global_delete, COMDAT

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__7D9C9A72_Sorts@cpp
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  0001f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00026	5f		 pop	 rdi
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
?__empty_global_delete@@YAXPEAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
